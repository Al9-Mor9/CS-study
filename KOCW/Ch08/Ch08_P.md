# [8] Memory Management

# 1. Logical vs. Physical Address

## (1) Logical vs. Physical Address

### Logical Address ( = Virtual Address)

- í”„ë¡œì„¸ìŠ¤ë§ˆë‹¤ ë…ë¦½ì ìœ¼ë¡œ ê°€ì§€ëŠ” ì£¼ì†Œ ê³µê°„
- ê° í”„ë¡œì„¸ìŠ¤ ë§ˆë‹¤ 0ë²ˆì§€ë¶€í„° ì‹œì‘
- **CPUê°€ ë³´ëŠ” ì£¼ì†ŒëŠ” logical address**
    - ë©”ëª¨ë¦¬ì˜ ì‹œì‘ ìœ„ì¹˜ëŠ” physical addressì— ë”°ë¼ ë‹¬ë¼ì§€ì§€ë§Œ ì‹¤í–‰ íŒŒì¼ ë‚´ì—ì„œì˜ logical addressëŠ” ë³€í•˜ì§€ ì•ŠìŒ
    - ì´ logical addressë¥¼ ë§¤ë²ˆ ë³€í™˜í•´ì„œ physical addressì— ì ‘ê·¼

### Physical Address

- ë©”ëª¨ë¦¬ì— ì‹¤ì œ ì˜¬ë¼ê°€ëŠ” ìœ„ì¹˜
- ë§¨ ì•„ë˜ì—ëŠ” ì»¤ë„ì´, ê·¸ ìœ„ì— ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ë“¤ì´ ì˜¬ë¼ê°ˆ ê²ƒ

ğŸ”” ì£¼ì†Œ ë°”ì¸ë”© : ì£¼ì†Œ ë³€í™˜ ì£¼ì†Œë¥¼ ê²°ì •í•˜ëŠ” ê²ƒ.

- ì–´ë–¤ í”„ë¡œì„¸ìŠ¤ê°€ **ë¬¼ë¦¬ì  ì£¼ì†Œ**ì˜ ì–´ë””ì— ì˜¬ë¼ê°ˆ ê²ƒì¸ê°€ë¥¼ ê²°ì •
- Symbolic Address â‡’ Logical Address â‡’ Physical Address

## (2) Address Binding

ì£¼ì†Œ ë°”ì¸ë”©ì´ ì–´ë–¤ ì‹œì ì—ì„œ ì´ë£¨ì–´ì§€ëŠ” ê°€ì— ë”°ë¼ì„œ ë‹¤ìŒê³¼ ê°™ì´ ë¶„ë¥˜ ê°€ëŠ¥

### Compile Time binding

- ë¬¼ë¦¬ì  ë©”ëª¨ë¦¬ ì£¼ì†Œê°€ ì»´íŒŒì¼ ì‹œ ì•Œë ¤ì§
- ì‹œì‘ ìœ„ì¹˜ ë³€ê²½ ì‹œ ì¬ì»´íŒŒì¼í•´ì•¼ í•¨
- ë¹„íš¨ìœ¨ì ì´ì§€ë§Œ ì»´í“¨í„° ì•ˆì—ì„œ í•˜ë‚˜ì˜ í”„ë¡œê·¸ë¨ë§Œ ëŒë¦¬ë˜ ì˜›ë‚ ì—ëŠ” ì´ ë°©ë²•ì„ ì“°ê¸°ë„ í–ˆìŒ
- ì»´íŒŒì¼ëŸ¬ëŠ” ì ˆëŒ€ ì½”ë“œ(absolute code) ìƒì„±
    - â“ Absolute Code

### Load Time Binding

- Loaderì˜ ì±…ì„í•˜ì— ë¬¼ë¦¬ì  ë©”ëª¨ë¦¬ ì£¼ì†Œ ë¶€ì—¬
- ì»´íŒŒì¼ëŸ¬ê°€ ì¬ë°°ì¹˜ê°€ëŠ¥ ì½”ë“œ(relocatable code)ë¥¼ ìƒì„±í•œ ê²½ìš° ê°€ëŠ¥
    - â“ ì¬ë°°ì¹˜ê°€ëŠ¥ ì½”ë“œ

### Execution Time Binding ( = Runtime Binding)

- ìˆ˜í–‰ì´ ì‹œì‘ëœ ì´í›„ì—ë„ í”„ë¡œì„¸ìŠ¤ì˜ ë©”ëª¨ë¦¬ ìƒ ìœ„ì¹˜ë¥¼ ì˜®ê¸¸ ìˆ˜ ìˆìŒ
- ì—¬ê¸°ë„ relocatable code
    - ì»´íŒŒì¼ íƒ€ì„ ë°”ì¸ë”© & ë¡œë“œ íƒ€ì„ ë°”ì¸ë”©ì€ í”„ë¡œê·¸ë¨ì´ ì‹œì‘ë  ë•Œ ì£¼ì†Œê°€ ì •í•´ì§€ê³  ë³€ê²½ë˜ì§€ ì•Šì§€ë§Œ ëŸ°íƒ€ì„ ë°”ì¸ë”©ì˜ ê²½ìš°ì—ëŠ” ë°”ë€” ìˆ˜ ìˆìŒ
- CPUê°€ ì£¼ì†Œë¥¼ ì°¸ì¡°í•  ë•Œë§ˆë‹¤ bindingì„ ì ê²€(address mapping table)
- í•˜ë“œì›¨ì–´ì ì¸ ì§€ì›ì´ í•„ìš”(MMU)

## (3) Memory-Management Unit(MMU)

### MMU

Logical Addressë¥¼ Physical addressë¡œ ë§¤í•‘í•´ì£¼ëŠ” í•˜ë“œì›¨ì–´ ì¥ì¹˜

### MMU scheme

ì‚¬ìš©ì í”„ë¡œì„¸ìŠ¤ê°€ CPUì—ì„œ ìˆ˜í–‰ë˜ë©° ìƒì„±í•´ë‚´ëŠ” ëª¨ë“  ì£¼ì†Œê°’ì— ëŒ€í•´ base register ( = relocation register)ì˜ ê°’ì„ ë”í•œë‹¤

### user program

Logical Addressë§Œì„ ë‹¤ë£¨ë©°, ì‹¤ì œ Physical AddressëŠ” ë³¼ ìˆ˜ë„, ì•Œ í•„ìš”ë„ ì—†ë‹¤. 

## (4) Hardware Support for Address Translation

MMUëŠ” relocation register & limit registerë¥¼ ì´ìš©í•´ ì£¼ì†Œë¥¼ ë³€í™˜í•¨ 

- Relocation Register ( = base register)
    - ì ‘ê·¼í•  ìˆ˜ ìˆëŠ” ë¬¼ë¦¬ì  ë©”ëª¨ë¦¬ ì£¼ì†Œì˜ ìµœì†Œê°’
    - ì‹œì‘ìœ„ì¹˜
        - ì—¬ê¸°ì—ë‹¤ê°€ logical addressë¥¼ ë”í•œ ê³³ì— ì ‘ê·¼
- Limit Register
    - ë…¼ë¦¬ì  ì£¼ì†Œì˜ ë²”ìœ„
    - í”„ë¡œê·¸ë¨ì´ ë§Œì•½ ì•…ì˜ì ì¸ í”„ë¡œê·¸ë¨ì´ë¼ í•„ìš”í•œ ë²”ìœ„ë¥¼ ë²—ì–´ë‚œ ê³³ì— ì ‘ê·¼í•˜ë ¤ê³  í•˜ëŠ” ê²½ìš°ë¥¼ ë§‰ê¸° ìœ„í•´ ë²”ìœ„ë¥¼ ê±¸ì–´ ë†“ìŒ
    - ì—¬ê¸°ë¥¼ ë²—ì–´ë‚˜ëŠ” ê²½ìš° trapì„ ë°œìƒì‹œì¼œ ì»¤ë„ì—ì„œ í™•ì¸

## (5) ìš©ì–´ë“¤

### Dynamic Loading

- í”„ë¡œì„¸ìŠ¤ ì „ì²´ë¥¼ ë©”ëª¨ë¦¬ì— ë¯¸ë¦¬ ì˜¬ë ¤ë†“ëŠ” ê²Œ ì•„ë‹ˆë¼ í•´ë‹¹ ë£¨í‹´ì´ ë¶ˆë ¤ì§ˆ ë•Œ ë©”ëª¨ë¦¬ì— loadí•˜ëŠ” ê²ƒ.
- memory utilization í–¥ìƒ
- ê°€ë”ì”© ì‚¬ìš©ë˜ëŠ” ë§ì€ ì–‘ì˜ ì½”ë“œì˜ ê²½ìš°ì— ìœ ìš©í•¨
- ìš´ì˜ì²´ì œì˜ íŠ¹ë³„í•œ ì§€ì› ì—†ì´ í”„ë¡œê·¸ë¨ì—ì„œ êµ¬í˜„ ê°€ëŠ¥.
    - ê·¸ëŸ¼ í”„ë¡œê·¸ë˜ë¨¸ê°€ ì´ê±¸ ì¼ì¼ì´ ë‹¤ êµ¬í˜„í•´ì¤˜ì•¼í•˜ëŠëƒ?
    - ê·¸ê±´ ì•„ë‹˜. **OSê°€ ì œê³µí•˜ëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬**ë¥¼ ì´ìš©.

### Overlays

- ë©”ëª¨ë¦¬ì— í”„ë¡œì„¸ìŠ¤ì˜ ë¶€ë¶„ ì¤‘ ì‹¤ì œ í•„ìš”í•œ ì •ë³´ë§Œì„ ì˜¬ë¦¼
- í”„ë¡œì„¸ìŠ¤ì˜ í¬ê¸°ê°€ ë©”ëª¨ë¦¬ë³´ë‹¤ í´ ë•Œ ìœ ìš©
- ìš´ì˜ì²´ì œì˜ ì§€ì›ì—†ì´ ì‚¬ìš©ìì— ì˜í•´ êµ¬í˜„
- ì‘ì€ ê³µê°„ì˜ ë©”ëª¨ë¦¬ë¥¼ ì‚¬ìš©í•˜ë˜ ì´ˆì°½ê¸° ì‹œìŠ¤í…œì—ì„œ **ìˆ˜ì‘ì—…ìœ¼ë¡œ í”„ë¡œê·¸ë˜ë¨¸ê°€ êµ¬í˜„**
    - Manual Overlay
    - êµ¬í˜„ì´ ë§¤ìš° ë³µì¡

### Swapping

- í”„ë¡œì„¸ìŠ¤ë¥¼ ì¼ì‹œì ìœ¼ë¡œ ë©”ëª¨ë¦¬ì—ì„œ *backing store*ë¡œ ì«“ì•„ë‚´ëŠ” ê²ƒ
    - Backing store ( = swap area)
        - ë””ìŠ¤í¬. ë§ì€ ì‚¬ìš©ìì˜ í”„ë¡œì„¸ìŠ¤ ì´ë¯¸ì§€ë¥¼ ë‹´ì„ ë§Œí¼ ì¶©ë¶„íˆ ë¹ ë¥´ê³  í° ì €ì¥ ê³µê°„.
- Swap in / out
    - ì¼ë°˜ì ìœ¼ë¡œ ì¤‘ê¸° ìŠ¤ì¼€ì¤„ëŸ¬(swapper)ì— ì˜í•´ swap out ì‹œí‚¬ í”„ë¡œì„¸ìŠ¤ë¥¼ ì„ ì •
    - priority-based CPU scheduling algorithm
        - priorityê°€ ë‚®ì€ í”„ë¡œì„¸ìŠ¤ëŠ” swap out, ë†’ì€ í”„ë¡œì„¸ìŠ¤ëŠ” swap in
    - Compile time, load time bindingì—ì„œëŠ” ì›ë˜ ë©”ëª¨ë¦¬ ìœ„ì¹˜ë¡œ swap in í•  ìˆ˜ ìˆì–´ì•¼ í•¨
        - ì›ë˜ ìˆë˜ ìë¦¬ë¥¼ ë¹„ì›Œë†”ì•¼(?) í•˜ê¸° ë•Œë¬¸ì— swappingì„ íš¨ê³¼ì ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ì—†ìŒ
    - Runtime bindingì—ì„œëŠ” ì¶”í›„ ë¹ˆ ë©”ëª¨ë¦¬ ì˜ì—­ ì•„ë¬´ ê³³ì—ë‚˜ ì˜¬ë¦´ ìˆ˜ ìˆìŒ
    - swap timeì€ ëŒ€ë¶€ë¶„ transfer time(ë°ì´í„° ì „ì†¡ ì‹œê°„)

### Dynamic Linking

- Linkingì„ ì‹¤í–‰ ì‹œê°„ê¹Œì§€ ë¯¸ë£¨ëŠ” ê¸°ë²•
    - Linking : ì»´íŒŒì¼ëœ ì—¬ëŸ¬ íŒŒì¼ë“¤ì„ ë¬¶ì–´ì„œ í•˜ë‚˜ì˜ ì‹¤í–‰ íŒŒì¼ë¡œ ì‹¤í–‰
- Static Linking
    - ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ í”„ë¡œê·¸ë¨ì˜ ì‹¤í–‰ íŒŒì¼ ì½”ë“œì— í¬í•¨ë¨
    - ì‹¤í–‰ íŒŒì¼ì˜ í¬ê¸°ê°€ ì»¤ì§
    - ë™ì¼í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ê°ê°ì˜ í”„ë¡œì„¸ìŠ¤ê°€ ë©”ëª¨ë¦¬ì— ì˜¬ë¦¬ë¯€ë¡œ ë©”ëª¨ë¦¬ë¥¼ ë‚­ë¹„í•¨
- Dynamic Linking
    - ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì‹¤í–‰ë  ë•Œ linkë¨
    - ë¼ì´ë¸ŒëŸ¬ë¦¬ í˜¸ì¶œ ë¶€ë¶„ì— ë¼ì´ë¸ŒëŸ¬ë¦¬ ë£¨í‹´ì˜ ìœ„ì¹˜ë¥¼ ì°¾ê¸° ìœ„í•œ ì‘ì€ ì½”ë“œë¥¼ ë‘ (stub)
    - ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì´ë¯¸ ë©”ëª¨ë¦¬ì— ìˆìœ¼ë©´ ê·¸ ë£¨í‹´ì˜ ì£¼ì†Œë¡œ ê°€ê³ , ì—†ìœ¼ë©´ ë””ìŠ¤í¬ì—ì„œ ì½ìŒ
    - ìš´ì˜ì²´ì œì˜ ë„ì›€ì´ í•„ìš”í•¨
    

# 2. Allocation of Physical Memory

## (1) Allocation of Physical Memory

### ë©”ëª¨ë¦¬ì˜ ë‘ ì˜ì—­

ë©”ëª¨ë¦¬ëŠ” ì¼ë°˜ì ìœ¼ë¡œ ë‘ ì˜ì—­ìœ¼ë¡œ ë‚˜ë‰˜ì–´ ì‚¬ìš©ë¨

- OS ìƒì£¼ ì˜ì—­
    - Interrupt vectorì™€ í•¨ê»˜ ë‚®ì€ ì£¼ì†Œì˜ ì˜ì—­ì„ ì‚¬ìš©
- ì‚¬ìš©ì í”„ë¡œì„¸ìŠ¤ ì˜ì—­
    - ë†’ì€ ì£¼ì†Œ ì˜ì—­ ì‚¬ìš©

## (2) Contiguous Allocation (ì—°ì† í• ë‹¹)

ê°ê°ì˜ í”„ë¡œì„¸ìŠ¤ê°€ ë©”ëª¨ë¦¬ì˜ ì—°ì†ì ì¸ ê³µê°„ì— ì ì¬ë˜ë„ë¡ í•˜ëŠ” ê²ƒ

### **Fixed partition allocation(ê³ ì • ë¶„í•  ë°©ì‹)**

- ë¬¼ë¦¬ì  ë©”ëª¨ë¦¬ë¥¼ ëª‡ ê°œì˜ **ì˜êµ¬ì  ë¶„í• **ë¡œ ë‚˜ëˆ”
- ë¶„í• ì˜ í¬ê¸°ê°€ ëª¨ë‘ ë™ì¼í•œ ë°©ì‹ê³¼ ì„œë¡œ ë‹¤ë¥¸ ë°©ì‹ì´ ì¡´ì¬
- ë¶„í•  ë‹¹ í•˜ë‚˜ì˜ í”„ë¡œê·¸ë¨ì„ ì ì¬
- ìœµí†µì„± ì—†ìŒ
    - ë™ì‹œì— ë©”ëª¨ë¦¬ì— loadë˜ëŠ” í”„ë¡œê·¸ë¨ì˜ ìˆ˜ê°€ ê³ ì •ë¨
    - ìµœëŒ€ ìˆ˜í–‰ ê°€ëŠ¥ í”„ë¡œê·¸ë¨ì˜ í¬ê¸°ì—ë„ ì œí•œì´ ìˆìŒ
- Internal fragmentation & external fragmentation ëª¨ë‘ ë°œìƒ
    - Internal fragmentation
        - í”„ë¡œê·¸ë¨ì´ ë“¤ì–´ê°ˆ ìˆ˜ ìˆì„ ë§Œí•œ í¬ê¸°ì˜ ê³µê°„ì´ ì—†ëŠ” ê²½ìš°
    - External fragmentation
        - í”„ë¡œê·¸ë¨ì´ ë“¤ì–´ê°ˆ ë§Œí•œ í¬ê¸°ì˜ ê³µê°„ì€ ìˆì§€ë§Œ ê·¸ ê³µê°„ì´ ìª¼ê°œì ¸ ìˆì–´ì„œ ì˜¬ë¦´ ìˆ˜ ì—†ëŠ” ê²½ìš°

### **Variable partition allocation(ê°€ë³€ ë¶„í•  ë°©ì‹)**

- í”„ë¡œê·¸ë¨ì˜ í¬ê¸°ë¥¼ ê³ ë ¤í•´ì„œ í• ë‹¹
- ë¶„í• ì˜ í¬ê¸°, ê°œìˆ˜ê°€ ë™ì ìœ¼ë¡œ ë³€í•¨
- ê¸°ìˆ ì  ê´€ë¦¬ ê¸°ë²•ì´ í•„ìš”
- External fragmentation ë°œìƒ

> âš ï¸ ********Hole********
> 
> - ê°€ìš© ë©”ëª¨ë¦¬ ê³µê°„
> - ë‹¤ì–‘í•œ í¬ê¸°ì˜ holeë“¤ì´ ë©”ëª¨ë¦¬ ì—¬ëŸ¬ ê³³ì— í©ì–´ì ¸ ìˆìŒ
> - í”„ë¡œì„¸ìŠ¤ê°€ ë„ì°©í•˜ë©´ ìˆ˜ìš© ê°€ëŠ¥í•œ holeì„ í• ë‹¹
> - ìš´ì˜ì²´ì œëŠ” ë‹¤ìŒì˜ ì •ë³´ë¥¼ ìœ ì§€í•¨
>     - í• ë‹¹ ê³µê°„ (í”„ë¡œì„¸ìŠ¤ê°€ ì˜¬ë¼ê°€ ìˆëŠ” ê³³)
>     - ê°€ìš© ê³µê°„ (í”„ë¡œì„¸ìŠ¤ë¥¼ ì˜¬ë¦´ ìˆ˜ ìˆëŠ” ê³³)

### Dynamic Storage-Allocation Problem

: ê°€ë³€ ë¶„í•  ë°©ì‹ì—ì„œ size nì¸ ìš”ì²­ì„ ë§Œì¡±í•˜ëŠ” ê°€ì¥ ì ì ˆí•œ holeì„ ì°¾ëŠ” ë¬¸ì œ

- First-fit
    - sizeê°€ n ì´ìƒì¸ ê²ƒ ì¤‘ ìµœì´ˆë¡œ ì°¾ì•„ì§€ëŠ” holeì— í• ë‹¹
    
    âš ï¸ Next-fit? ë©”ëª¨ë¦¬ì˜ ì‹œì‘ë¶€í„°ë³´ëŠ” first-fitê³¼ ë‹¬ë¦¬ ìµœê·¼ì— í• ë‹¹ëœ ê³³ì—ì„œë¶€í„° ì‹œì‘
    
- Best-fit
    - sizeê°€ n ì´ìƒì¸ ê°€ì¥ ì‘ì€ holeì— í• ë‹¹
    - holeì˜ ë¦¬ìŠ¤íŠ¸ê°€ í¬ê¸° ìˆœìœ¼ë¡œ ì •ë ¬ë˜ì§€ ì•Šì€ ê²½ìš° ëª¨ë“  holeì˜ ë¦¬ìŠ¤íŠ¸ë¥¼ íƒìƒ‰í•´ì•¼ í•¨
    - ë§ì€ ìˆ˜ì˜ ì‘ì€ holeë“¤ì´ ìƒì„±ë¨
- Worst-fit
    - ê°€ì¥ í° holeì— í• ë‹¹
    - ëª¨ë“  ë¦¬ìŠ¤íŠ¸ë¥¼ íƒìƒ‰í•´ì•¼ í•¨
    - ìƒëŒ€ì ìœ¼ë¡œ ì•„ì£¼ í° holeë“¤ì´ ìƒì„±ë¨
- First-fitê³¼ best-fitì´ worst-fitë³´ë‹¤ ì†ë„ì™€ ê³µê°„ ì´ìš©ë¥  ì¸¡ë©´ì—ì„œ íš¨ê³¼ì ì¸ ê²ƒìœ¼ë¡œ ì•Œë ¤ì§

> âš ï¸ **Compaction**
> 
> - external fragmentationì„ í•´ê²°í•˜ëŠ” í•œ ë°©ë²•
> - ì‚¬ìš© ì¤‘ì¸ ë©”ëª¨ë¦¬ ì˜ì—­ì„ í•œ êµ°ë°ë¡œ ëª°ê³  holeì€ ë‹¤ë¥¸ ê³³ìœ¼ë¡œ ëª°ì•„ í° blockì„ ë§Œë“œëŠ” ê²ƒ
> - ë§¤ìš° ë¹„ìš©ì´ ë§ì´ ë“¦
> - ìµœì†Œí•œì˜ ë©”ëª¨ë¦¬ ì´ë™ìœ¼ë¡œ compactioní•˜ëŠ” ê²ƒì€ ë§¤ìš° ë³µì¡í•œ ë¬¸ì œ
> - í”„ë¡œì„¸ìŠ¤ ì£¼ì†Œê°€ ì‹¤í–‰ ì‹œê°„ì— ë™ì ìœ¼ë¡œ ì¬ë°°ì¹˜ ê°€ëŠ¥í•œ ê²½ìš°ì—ë§Œ ìˆ˜í–‰ë  ìˆ˜ ìˆìŒ

# 3. Non-contiguous Allocation (ë¶ˆì—°ì† í• ë‹¹)

í•˜ë‚˜ì˜ í”„ë¡œì„¸ìŠ¤ê°€ ë©”ëª¨ë¦¬ì˜ ì—¬ëŸ¬ ì˜ì—­ì— ë¶„ì‚°ë˜ì–´ ì˜¬ë¼ê°ˆ ìˆ˜ ìˆìŒ

## Paging

í”„ë¡œê·¸ë¨ì„ ì´ë£¨ëŠ” logical memoryë“¤ì„ ì¼ì •í•œ í¬ê¸°ì˜ pageë¡œ ë‚˜ëˆ„ê³  ì´ pageë“¤ì„ non-contiguousí•˜ê²Œ, ì¼ë¶€ëŠ” backing storage, ì¼ë¶€ëŠ” physical memoryì— ì§‘ì–´ ë„£ìŒ

### Basic Method

- physical memoryë¥¼ ë™ì¼í•œ í¬ê¸°ì˜ frameìœ¼ë¡œ ë‚˜ëˆ” (ì£¼ë¡œ 4kb)
- logical memoryë¥¼ ë™ì¼í•œ í¬ê¸°ì˜  pageë¡œ ë‚˜ëˆ” (frameì˜ í¬ê¸°ì™€ ë™ì¼)
- ëª¨ë“  ê°€ìš© frameë“¤ì„ ê´€ë¦¬
- page tableì„ ì‚¬ìš©í•´ logical addressë¥¼ physical addressë¡œ ë³€í™˜
    
    > logical addressëŠ” í˜ì´ì§€ ë²ˆí˜¸ + í˜ì´ì§€ ì˜¤í”„ì…‹ìœ¼ë¡œ êµ¬ì„±ë˜ì–´ ìˆìŒ
    í˜ì´ì§€ ë²ˆí˜¸ë¶€ë¶„ì´ page tableì„ í†µí•´ í”„ë ˆì„ ë²ˆí˜¸ë¡œ ë°”ë€Œê³  ì˜¤í”„ì…‹ì€ ê·¸ëŒ€ë¡œ ê°€ì ¸ê°
    > 
- external fragmentation ë°œìƒí•˜ì§€ ì•ŠìŒ
- internal fragmentationì€ ë°œìƒ ê°€ëŠ¥

### page table

- ì´ í˜ì´ì§€ë“¤ì´ physical memoryì˜ ì–´ë””ì— ë“¤ì–´ê°€ ìˆëŠ”ì§€ë¥¼ ë„£ì–´ ë†“ì€ í…Œì´ë¸”
- Page tableì€ main memoryì— ìƒì£¼.
    - ì´ í…Œì´ë¸”ì€ ë ˆì§€ìŠ¤í„°, ìºì‹œ ë“±ì—ëŠ” ë„£ê¸°ì—ëŠ” ë„ˆë¬´ í¼
- Page-table base register(PTBR)ê°€ page tableì„ ê°€ë¦¬í‚´
- Page-table length register(PTLS)ëŠ” í…Œì´ë¸”ì˜ í¬ê¸°ë¥¼ ë³´ê´€
- ëª¨ë“  ë©”ëª¨ë¦¬ ì ‘ê·¼ ì—°ì‚°ì—ëŠ” 2ë²ˆì˜ ë©”ëª¨ë¦¬ ì ‘ê·¼ì´ í•„ìš”
    - page tableì— 1ë²ˆ, ì‹¤ì œ data/instructionì— 1ë²ˆ
    - í° ì˜¤ë²„í—¤ë“œ
- ì†ë„ í–¥ìƒì„ ìœ„í•´ associative register ë˜ëŠ” translation look-aside buffer(TLB)ë¼ ë¶ˆë¦¬ëŠ” ê³ ì†ì˜ lookup hardware cacheë¥¼ ì‚¬ìš©í•¨

### TLB

- ì£¼ì†Œ ë³€í™˜ì„ ìœ„í•œ ìºì‹œ
- í˜ì´ì§€ ë²ˆí˜¸ì™€ í”„ë ˆì„ì˜ ë²ˆí˜¸ë¥¼ ìŒìœ¼ë¡œ ê°€ì§€ê³  ìˆìŒ
- TLBë¥¼ í†µí•´ ì£¼ì†Œ ë³€í™˜ì´ ê°€ëŠ¥í•œì§€ë¥¼ ì‚´í´ë´„
    - hit ì‹œ ë°”ë¡œ ë¬¼ë¦¬ ë©”ëª¨ë¦¬
    - miss ì‹œ page tableì„ ë³´ê³ , TLBë¥¼ ê°±ì‹ 
- TLB ì¡°íšŒ ì‹œì—ëŠ” TLBì˜ ì „ì²´ í•­ëª©ì„ ì‚´í´ë³´ì•„ì•¼ í•¨
    - ì´ ë˜í•œ overheadê°€ í¬ê¸° ë•Œë¬¸ì—, ì¼ë°˜ì ìœ¼ë¡œ ë³‘ë ¬ì ìœ¼ë¡œ searchí•  ìˆ˜ ìˆëŠ” associative registerë¥¼ ì´ìš©í•´ì„œ êµ¬í˜„í•¨.
- TLBëŠ” ë…¼ë¦¬ì  ì£¼ì†Œë¥¼ ë‹¤ë£¨ê³  ìˆìœ¼ë¯€ë¡œ í”„ë¡œì„¸ìŠ¤ë§ˆë‹¤ ê°ì ê°€ì ¸ì•¼ í•¨
    - ë”°ë¼ì„œ ë¬¸ë§¥ ì „í™˜ì´ ì´ë£¨ì–´ì§€ë©´ flush

> Effective Access Time
> 
> - Associative Register Lookup Time = $\epsilon$
> - Memory Cycle Time = 1
> - Hit ratio = $\alpha$
> - Effective Access Time
> 
> $$
> EAT = (1 + \epsilon)\alpha + (2 + \epsilon)(1 - \alpha) \\
> = 2 + \epsilon - \alpha
> $$
> 

### Two-level Page Table

- í˜„ëŒ€ ì»´í“¨í„°ëŠ” ì£¼ì†Œ ê³µê°„ì´ ë§¤ìš° í° í”„ë¡œê·¸ë¨ì„ ì§€ì›í•¨
- 32-bit ì£¼ì†Œì˜ ê²½ìš° 4Gì˜ ì£¼ì†Œ ê³µê°„ì´ í•„ìš”
    - page sizeê°€ 4Kì¼ ê²½ìš° 1Mê°œì˜ page table entryê°€ í•„ìš”
    - ê° page entryê°€ 4Bì¼ ë•Œ, í”„ë¡œì„¸ìŠ¤ë‹¹ 4Mì˜ page tableì´ í•„ìš”
    - ê·¸ëŸ¬ë‚˜ ëŒ€ë¶€ë¶„ì˜ í”„ë¡œê·¸ë¨ì€ 4Gì˜ ì£¼ì†Œ ê³µê°„ ì¤‘ ì§€ê·¹íˆ ì¼ë¶€ë§Œ ì‚¬ìš©í•˜ë¯€ë¡œ page table ê³µê°„ì´ ì‹¬í•˜ê²Œ ë‚­ë¹„ë˜ëŠ” ë¬¸ì œê°€ ë°œìƒ
- Inner table & Outer tableë¡œ êµ¬ì„±
    - logical addressì˜ êµ¬ì„±
        
        
        | P1(1) : outer page tableì˜ index | P2(10): outer page tableì˜ pageì—ì„œì˜ ë³€ìœ„(displacement) | d(12) |
        | --- | --- | --- |
        - 20-bitì˜ page number
            - page tableì´ pageë¡œ êµ¬ì„±ë˜ë¯€ë¡œ page numberë„ ë‹¤ìŒê³¼ ê°™ì´ ë‚˜ë‰¨
                - 10-bitì˜ page number
                - 10-bitì˜ page offset
                    - Inner pageì˜ ì—”íŠ¸ë¦¬ ìˆ˜ê°€ 1K(4K / 4)ê°œ ìˆìœ¼ë¯€ë¡œ 10bitê°€ í•„ìš”
        - 12-bitì˜ page offset
            - physical addressì˜ í•œ í”„ë ˆì„ì´ 4KBì´ë¯€ë¡œ byte ë‹¨ìœ„ë¡œ ì£¼ì†Œ êµ¬ë¶„ì„ í•˜ë ¤ë©´ 12bitì´ í•„ìš”í•˜ë¯€ë¡œ
    - P1ì„ ë³´ê³  í˜ì´ì§€ë¥¼ ì°¾ê³ , ì°¾ì€ í˜ì´ì§€ì—ì„œ P2ë¡œ ê°€ì„œ frame numberë¥¼ ì°¾ìŒ. ë§ˆì§€ë§‰ offsetì„ ë³´ê³  physical addressì— ì ‘ê·¼
- ì‚¬ì‹¤ Inner page tableì´ frame ê°œìˆ˜ë§Œí¼ ë§Œë“¤ì–´ì§€ëŠ”ë° ì‹œê³µê°„ì ìœ¼ë¡œ ëª¨ë‘ ì†í•´ ì•„ë‹Œê°€?
    - ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ê²½ìš°, ê°€ëŠ¥í•œ ëª¨ë“  logical addressì— ëŒ€í•´ì„œ ê·¸ í¬ê¸°ë§Œí¼ì˜ page tableì˜ ì—”íŠ¸ë¦¬ê°€ ë§Œë“¤ì–´ì ¸ì•¼ í•¨
    - two-level page tableì€ ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ì£¼ì†Œ ê³µê°„ì— ëŒ€í•œ outer page tableì˜ ì—”íŠ¸ë¦¬ ê°’ì€ NULLì´ ë˜ì–´ inner tableì´ ë§Œë“¤ì–´ì§€ì§€ ì•Šê³  ê²°ê³¼ì ìœ¼ë¡œ ì´ë“

### Segmentation

### Paged Segmentation
