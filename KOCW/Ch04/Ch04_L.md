# 4강 프로세스 관리

## 프로세스 생성
copy-on-write
cow
system call을 통해서 만듦.(fork system call)

- 부모 프로세스가 자식 프로세스 생성
- 프로세스의 트리 형성
- 프로세스는 자원을 필요로함
    운영제체로부터 받음.

- 자원의 공유
    부모와 모든 자원 공유
    일부 공유
    전혀 공유하지 않음

- 수행
    부모와 자식은 공존하는 모델
    자식이 종료될 때까지 기다리는 모델

- 주소 공간
    자식은 부모의 공간을 복사함
    자식은 그 공간에 새로운 프로그램을 올림

- 프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려줌.(exit)
    자식이 부모에게 output data를 보낸다.
    프로세스의 각종 자원들이 운영체제에게 반납됨

- 부모 프로세스가 자식의 수행을 종료시키는 경우
    자식이 할당 자원의 한계치를 넘어섬.
    자식에게 할당된 태스크가 더 이상 필요하지 않음
    부모가 종료하는 경우
        원래 자식이 먼저 종료됨.
        운영체제는 부모 프로세스가 종료하는 경우 자식이 수행되도록 두지 않는다.


- fork()
부모 프로세스를 복제생성

int main()
{
    int pid;
    pid = fork(); 
    ...
}

fork를 하게 되면 자식으로 넘어가고, pc까지 같이 복제되서 또 fork 되지는 않는다.
지가 원본...? 이라고 주장도 가능..

- exec()

int main()
{
    int pid;
    pid = fork(); 
    if (pid == 0)
    {
        printf ...
        execlp(...)
    }
    ...
}

자식을 만들고, execlp로 덮어씌운다. 이때, 인자를 넘기는 방식.
자식을 만들지 않아도 된다..
아예 새로운 프로그램을 덮어씌운다. 자기자신이면 무한재귀인가

- wait()

프로세스 A가 wait() 시스템 콜을 호출하면
    커널은 child가 종료될 때까지 프로세스 A를 sleep 시킨다(block)
    child process가 종료되면 커널은 프로세스 A를 깨운다(ready)


- exit()

프로세스의 종료

자발적 종료
    마지막 문장 수행 후 exit() 시스템 콜
    명시적으로 적어주지 않아도 main함수가 리턴되는 위치에 컴파일러가 넣어줌
비자발적 종료
    부모 프로세스가 자식 프로세스를 강제 종료
    키보드로 kill, break
    부모가 종료




## 프로세스 간 협력


- 독립적 프로세스
    프로세스는 각자의 주소 공간을 가지고 수행. 
    하나의 프로세스가 다른 프로세스의 수행에 영향 못 미치는 것이 원칙

- 협력 프로세스
    협력 매커니즘을 통해 영향을 미칠 수 있다.


- 프로세스 간 협력 매커니즘(IPC: Interprocess Communication)

    message passing : 커널을 통해 메시지 전달. 원칙적으로는 전달 불가.
        공유 변수를 일체 사용하지 않고 통신하는 시스템
        Direct communication : 통신하려는 프로세스 이름 명시적 표시
        Indirect '' : mailbox 또는 port를 통해 메시지를 간접 전달.

    shared memory :  서로 다른 프로세스 간에도 일부 주소 공간을 공유하게 함.
        미리 커널에 맵핑을 해놔야함..

    thread : 사실상 하나의 프로세스이므로 프로세스 간 협력으로 보기에는 어렵지만, 주소 공간을 공유하므로 협력이 가능.




