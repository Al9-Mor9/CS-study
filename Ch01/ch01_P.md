# 디자인 패턴

## 1.1. 디자인 패턴

### 1.1.1 싱글톤 패턴

하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴. DB 연결 모듈에 많이 사용한다. 한 클래스에 단 하나의 인스턴스만이 필요한 경우에 사용한다. 하나의 인스턴스를 다른 모든 모듈들이 공유하며 사용한다.

+ 장점) 
  + 메모리 사용이 줄어든다. 데이터 공유가 쉬워 진다.
+ 단점) 
  + 구현하는 데에 코드가 많이 필요하다(멀티스레드 환경에서의 어려움). 
  + 테스트하기 어렵다.(매번 인스턴스의 상태 초기화 필요하다).
    + 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴이므로 각 테스트마다 독립적인 인스턴스를 만들기가 어렵다. 
  + 의존 관계상 클라이언트가 구체 클래스에 의존한다.
    + 사용하기 쉽고 실용적이지만 모듈간의 결합을 강하게 만든다.
    + **의존성 주입 원칙** : 상위 모듈은 하위 모듈에서 어떤 것도 가져오지 않아야 한다. 둘 다 추상화에 의존해야한다. 추상화는 구체화에 의존하지 않아야 한다.

```java
/*자바에서의 싱글톤 패턴*/

class Singleton{
    private static Singleton instance = new Singleton(); //처음에 자기 자신의 static instance를 만들고
    
    private static Singleton(){} //생성자는 외부에서 접근할 수 없게 private으로 둔다.
    
    public static Singleton getInstance(){//외부에서 이 객체를 사용해야 할 때는 만들어진 instance를 반환한다
        return this.instance;
    } 
}
```



### 1.1.2 팩토리 패턴

객체를 사용하는 코드에서 객체 생성 부분을 떼내 추상화한 패턴. 상위 클래스가 중요 뼈대를 결정하고 하위 클래스에서 객체 생성에 관한 구체적 내용을 결정.

상위 클래스와 하위 클래스가 분리되어있으므로 느슨한 결합을 가지고 상위 클래스에서는 인스턴스 생성  방식에 대해 알 필요가 없으므로 더 많은 유연성을 가짐.

```java
/*자바에서의 팩토리 패턴*/

public interface Product{
    void func();
}

public class Car implements Product{
    @Override    
    public static Car getInstance() {
        if (instance == null) {
            instance = new Car();
        }
        return instance;
    }
    public void func(){
        //...
    }
}

public class Boat implements Product{
    @Override
    public void func(){
        //...
    }
}

public class ProductFactory{
    public Product getProduct(String productType){
        if (productType == null) return null;
        if (productType.equals("Car"))
        instance = Car.getInstance();
        return instance;
        if (productType.equals("Boat")) return new Boat();        
    }
}

```

당연히 팩토리 패턴과 싱글톤 패턴을 함께 쓸 수도 있다.

### 1.1.3 전략 패턴

객체의 행위를 바꾸고 싶은 경우, 직접 수정하지 않고 캡슐화한 알고리즘을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴.



### 1.1.4 옵저버 패턴

주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록의 옵저버들에게 변화를 알려주는 디자인 패턴

+ 주체 : 객체의 상태 변화를 보는 관찰자
+ 옵저버: 객체의 상태 변화에 따라 전달되는 메서드 등을 기반으로 '추가 변화 사항' 이 생기는 객체

주체-객체를 따로 두지 않고 하나의 객체를 기반으로 구축하기도 함. 활용 예는 트위터

### 1.1.5 프록시 패턴과 프록시 서버

대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 객체 앞의 인터페이스 역할을 하는 디자인 패턴

객체의 속성, 변환을 보완, 보안 등에 사용

### 1.1.6 이터레이터 패턴

이터레이터를 사용해 컬렉션 요소에 접근하는 디자인 패턴

ex) C++의 vector, map, set 등은 이터레이터를 이용

* 이터러블한 객체: 반복 가능한 객체. 배열의 일반화

### 1.1.7 노출 모듈 패턴

**즉시 실행 함수** 를 통해 접근 제어자를 만드는 패턴. 

+ 즉시 실행 함수란?
  + 함수를 정의하고 변수를 함수에 저장하고 실행하는 과정이 아니라 함수를 정의하자마자 바로 호출하는 함수.
  + 초기화 코드 및 라이브러리 내 전역 변수의 충돌 방지 등에 사용

+ 장점
  + 깔끔함
  + private한 데이터를 제공
  + 명시적으로 public 메소드, 변수를 제공, 명시성을 높임
+ 단점
  + private 메소드에 접근할 수 없음
  + private 메소드에 대한 함수 확장에 어려움이 있음



### 1.1.8 MVC 패턴(:star:)

+ **모델**(Model), **뷰**(View), **컨트롤러**(Controller)로 이루어진 디자인 패턴.
+ 장점
  + 개발 프로세스에서 각각의 구성 요소에만 집중해 개발할 수 있음
  + 재사용성과 확장성이 높음
+ 단점
  + 복잡해질 수록 모델-뷰의 관계가 복잡해짐.
  + View-Model 사이의 의존성이 높음(-> ?)

+ 모델
  + 앱의 데이터. DB, 상수, 변수 등
  + 컨트롤러를 통해 모델을 생성 / 갱신
+ 뷰
  + 사용자 인터페이스 요소.
  + 모델 정보를 따로 저장하지 않고, 그 내용을 화면에 표시하는 정보만 가져야 함
  + 변경이 있을 때 컨트롤러에 이를 전달
+ 컨트롤러
  + 모델-뷰를 잇는 요소. 메인 로직을 담당.
  + 모델, 뷰의 생명주기를 관리하고 둘에 변경이 일어나면 이를 해석, 각 구성 요소에 해당 내용에 대한 정보를 전달.

### 1.1.9 MVP 패턴

MVC 패턴의 컨트롤러가 **프레젠터**로 교체된  패턴

뷰-프레젠터가 일대일 관계를 가지고 있음. 

+ MVC는 한 컨트롤러가 여러 뷰를 선택하는 일대다 구조이며, 뷰를 직접 업데이트하지 않음)
+ MVP는 View-Model의 의존성을 해결(Presenter를 통해서만 데이터를 전달 받음)
+ 대신 View-Presenter 사이의 의존성이 높아짐



### 1.1.10 MVVM 패턴

MVC의 컨트롤러가 View Model로 바뀐 패턴

+ View Model 

  + 뷰를 추상화한 계층.

  + 커맨드 패턴과 데이터 바인딩 패턴을 사용하여 구현됨.

    + 커맨드: 여러 요소에 대한 처리를 한 액션으로 처리하게 함

    + 데이터 바인딩: 화면의 데이터와 브라우저의 메모리 데이터를 일치시킴.

      ​					-> 뷰 모델이 변경되면 뷰도 변함.

      

  + View Model-View는 일대다 관계 -> VM-View 사이의 의존성을 업앰

  + Model-VM-View 모두 의존성이 없음.

  + VM 설계가 쉽지 않다는 한계.

## 1.2 프로그래밍 패러다임

### 1.2.1 선언형 & 함수형

함수형 프로그래밍은 선언형 프로그래밍의 한 종류. 작은 **순수 함수**들을 쌓아 로직을 구현하고, **고차 함수**를 통해 재사용성을 높인 프로그래밍 패러다임

+ 순수 함수 : 출력이 입력에만 의존하는 함수
+ 고차 함수 : 함수가 함수를 값처럼 매개변수로 받아 로직을 생성할 수 있음.
+ 일급 객체 : 함수에 인자로 넘길 수 있고, 수정할 수 있고, 변수에 대입할 수도 있는... 그런 객체



### 1.2.2 객체지향 프로그램

객체들의 집합으로 프로그래밍의 상호작용을 표현. 데이터를 객체로 취급, 객체 내부의 메서드를 활용하는 방식.

+ 특징(:star:)
  + 추상화
    + 핵심 개념, 기능을 간추려 표현
  + 캡슐화
    + 정보 일부를 감춤
  + 상속성
    + 상위 클래스의 특성을 하위 클래스가 이어 받아 재사용/추가/확장할 수 있음
  + 다형성
    + 한 메서드나 클래스가 다양한 방법으로 동작 가능(ex. 오버로딩, 오버라이딩)
+ 설계 원칙(:star:)
  + **S**ingle Responsibility Principle, 단일 책임 원칙
    + 모든 클래스는 각각 하나의 책임만 가져야 함.
    + 어떤 로직에 관한 클래스는 오직 그 클래스에만 관련되어야 함.
  + **O**pen Closed Principle, 개방-폐쇄 원칙
    + 코드를 확장하기는 쉬워야 하지만, 기존의 코드가 변경되는 일은 적어야 함

    

  + **L**iscov Substitution Principle, 리스코프 치환 원칙
    + 프로개름(PYS식 명명)의 객체는 프로그램의 정확성을 깨뜨리지 않으면서도 하위 타입의 인스턴스로 바뀔 수 있어야 함.
    + 부모 객체에 자식 객체를 넣어도 문제 없어야 함
  + **I**nterface Segregation Principle, 인터페이스 분리 원칙
    + 하나의 일반적인 인터페이스보다, 여러 개의 구체적인 인터페이스를 만들 것.
  + **D**ependency Inversion Principle, 의존 역전 원칙
    + 상위 계층은 하위 계층의 구현에 의존하지 않아야 함.

    상호의존되는 클래스가 있나?
    
    인터페이스 동물 걷먹싸 
    -> 구현체       어라라 구른다.
    개발과정에 있어서 역전된다?
    변하기 쉬운 것에 영향을 덜 받는

    네발 두발 걷
    모든 동물은 네발로 걸어야 하지
    철학적 접근

    객체지향 스터디 ㄷㄷ;
    스터디 중독자 하림의 관심을 끄는 대박 스터디;
    AI 스터디...


    

    역전되는 상황이 발생 하지말라고 넣은거아님?

    

### 1.2.3 절차형 프로그래밍

수행되어야 할 연속적인 계산 과정으로 이루어진 로직. 일의 진행 방식대로 코드를 구현.
