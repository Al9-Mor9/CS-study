[ Chapter 1. 디자인 패턴과 프로그래밍 패러다임 ]
# 1.1 디자인 패턴(Design Pattern)
- 디자인 패턴: 프로그램을 설계할 때 자주 발생하는 문제점들을 객체 간의 상호 관계 등을 이용해 해결할 수 있도록 하나의 "규약" 형태로 만들어 놓은 것

# 📌 1.1.1 싱글톤 패턴(Singleton Pattern)
- 싱글톤 패턴: **하나의 클래스에 오직 하나의 인스턴스만** 가지는 패턴
  - 데이터베이스 연결 모듈에 사용

## ✔️ 싱글톤 패턴의 특징
1. 장점: 인스턴스 생성 비용 감소 
   - 하나의 인스턴스를 만들어놓고 다른 모듈들이 공유하며 사용하기 때문
2.  단점: 의존성 &uarr;
3. 사용 예시
   - Node.js-MongoDB 연결 &rarr; mongoose 모듈
   - Node.js-MySQL DB 연결

## ✔️ 싱글톤 패턴의 단점
- **TDD(Test Driven Development)** 어려움
   - TDD란? 테스트 주도 개발, 테스트(틀)를 먼저 만들고 구현 클래스를 만드는 것
   - 단위 테스트를 진행하기 때문에 테스트가 서로 *독립적*이어야 함( == 어떤 순서로든 실행가능)

## ✔️ 해결 방법: 의존성 주입(Dependency Injection)
- <img width="400" alt="image" src="https://user-images.githubusercontent.com/108309396/233775820-53bee436-ffb7-44e2-8935-a3641bd3c080.png">
- 메인 모듈이 '직접' 하위 모듈에 대한 의존성을 주지X, 중간에 **의존성 주입자**(dependency injector)가 가로채 메인 모듈이 '간접'적으로 의존성을 주입하는 방식
  - 모듈 간의 결합을 느슨하게 만들 수 있음
  - 의존성이 떨어진다 == 디커플링이 된다

### 의존성 주입의 장점
- 모듈들을 쉽게 교체할 수 있는 구조가 되어 **테스팅 하기 쉽고 마이그레이션이 수월**
- 구현할 때 추상화 레이어를 넣고 이를 기반으로 구현체를 넣어주기 때문에
  - 애플리케이션 의존성 방향이 일관됨
  - 애플리케이션을 쉽게 추론 가능
  - 모듈 간의 관계들이 명확해짐

### 의존성 주입의 단점
- 모듈들이 더욱 분리되므로 클래스 수&uarr; &rarr; **복잡성&uarr;**
- 약간의 런타임 페널티 발생

### 의존성 주입 원칙
- 상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야 함
- 둘 다 추상화에 의존해야 함
- 이 때 추상화는 세부 사항에 의존하지 말아야 함


외부에 작성해 놓은 인터페이스를 끌어다가 가져다 쓴다 -> "메소드를 외부에 둔다."
청소기 버튼 눌러만 지게 두고. 
동작은 외부에 구현


@autowired 
의존성 주입을 편의성있게 가능하게 해준다?

Daoimplement dao = new Daoimplement();


# 📌 1.1.2 팩토리 패턴(Factory Pattern)
- 팩토리 패턴: 객체를 사용하는 코드에서 **객체 생성 부분을 떼어내 추상화한 패턴**
  - 상속 관계에 있는 두 클래스
  - 상위 클래스가 중요한 뼈대를 결정
  - 하위 클래스가 객체 생성에 관한 구체적인 내용을 결정

## ✔️ 팩토리 패턴의 특징
1. 상위 클래스와 하위 클래스가 분리되기 때문에 *느슨한 결합*을 가짐
2. 상위 클래스: 인스턴스 생성 방식을 알 필요X &rarr; *유연성*&uarr;
3. 객체 생성 로직이 따로 분리되어 있기 때문에 리팩토링이 수월 &rarr; *유지보수성*&uarr;

> ### [참고] `static` 정적 메서드
> - 인스턴스 없이 호출 가능 &rarr; 메모리 절약 가능
> - 개별 인스턴스에 묶이지 않으며 클래스 내의 함수를 정의할 수 있음


# 📌 1.1.3 전략 패턴(Strategy Pattern)
- 전략 패턴(== 정책 패턴): 객체의 행위를 바꾸고 싶은 경우, **전략이라고 부르는 '캡슐화한 알고리즘'을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴**
  - 컨텍스트란? 개발자가 어떠한 작업을 완료하는 데 필요한 모든 관련 정보
- 사용 예시: passport - Node.js에서 인증 모듈을 구현할 때 쓰는 미들웨어 라이브러리


# 📌 1.1.4 옵저버 패턴(Observer Pattern)
- 옵저버 패턴: **주체가 어떤 객체의 상태 변화를 관찰하며 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴**
- 주체: 객체의 상태 변화를 관찰하는 관찰자
- 옵저버들: 이 객체의 상태 변화에 따라 '추가 변화 사항'이 생기는 객체들
1. 주체와 객체가 분리된 경우  
<img width="300" alt="image" src="https://user-images.githubusercontent.com/108309396/233776999-0d4ff162-d8dd-4e72-888d-fafa174d56f1.png">

2. 상태가 변경되는 객체를 주체로 두는 경우  
<img width="300" alt="image" src="https://user-images.githubusercontent.com/108309396/233777009-0e19ec84-b520-4b79-a4f5-c74d6582b095.png">

## ✔️ 옵저버 패턴의 사용 예시
1. 트위터 시스템
   - 어떤 주체를 '팔로우'했다면 주체가 포스팅할 때마다 알림이 '팔로워'에게 감  
  <img width="480" alt="image" src="https://user-images.githubusercontent.com/108309396/233777202-105dabb7-74ea-4e40-a201-553e0dd23a1b.png">
2. MVC(Model-View-Controller) 패턴
   - 주체인 model에 변화가 생겨 update() 메서드로 옵저버인 view에게 알려주고 이를 기반으로 controller가 작동  
  <img width="495" alt="image" src="https://user-images.githubusercontent.com/108309396/233777215-33e6dd28-25b8-4397-a171-bea1d6139afd.png">

### [참고] Java: 상속과 구현
1. 상속(`extends`)
   - 자식 클래스가 부모 클래스의 메서드 등을 상속받아 사용, 추가 및 확장 가능
   - 재사용성, 중복성 최소화
2. 구현(`implements`)
   - 부모 인터페이스(Interface)를 자식 클래스에서 overriding하여 구현
   - 상속과는 달리 **반드시 부모 클래스의 메서드를 overriding하여 구현해야 함**
3. 상속은 일반 클래스, `abstract` 클래스를 기반으로 구현, 구현은 `interface`를 기반으로 구현

## ✔️ 자바스크립트에서의 옵저버 패턴
- **프록시 객체**를 통해 구현 가능
- 프록시 객체란? 어떤 대상의 기본적인 동작 작업을 **가로챌 수 있는 객체**를 뜻하며, 두 개의 매개변수를 가짐
  - target: 프록시할 대상
  - handler: 프록시 객체의 target 동작을 가로채서 정의할 동작들이 정의된 함수
- `get()`: 속성과 함수에 대한 접근을 가로챔
- `has()`: in연산자의 사용을 가로챔
- `set()`: 속성에 대한 접근을 가로챔

## ✔️ Vue.js 3.0의 옵저버 패턴
- `ref`나 `reactive`로 정의하면 해당 값이 변경되었을 때 자동으로 DOM에 있는 값이 변경됨

# 📌 1.1.5 프록시 패턴(Proxy Pattern)과 프록시 서버
- 프록시 패턴: 대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 디자인 패턴
- 객체의 속성, 변환 등을 보완 &rarr; 보안, 데이터 검증, 캐싱, 로깅에 사용
- 프록시 객체, 프록시 서버로도 활용  
<img width="566" alt="image" src="https://user-images.githubusercontent.com/108309396/233788211-19feec3a-66b7-4560-b4f9-267ad73a5068.png">

> ### [참고] 프록시 서버에서의 캐싱
> - 캐시 안에 정보를 담아두고, 해당 정보 요청 시 원격 서버에 요청하지 않고 캐시 안에 있는 데이터를 활용하는 것
> - 불필요하게 외부와 연결하지 않아 **트래픽**&darr;

## ✔️ 프록시 서버(Proxy Server)
- 프록시 서버: 서버와 클라이언트 사이에서 **클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속**할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램
- 서버 앞단에 둬서 캐싱, 로깅, 데이터 분석을 서버보다 먼저 하는 서버

## ✔️ 프록시 서버 사용 예시
## 1. nginx
- 비동기 이벤트 기반의 구조와 다수의 연결을 효과적으로 처리 가능한 웹 서버
> ### [참고] 비동기(Async)란? 
> - 어떠한 작업이 동시에 일어날 수 있는 개념이며, 요청과 결과 반환이 동시에 일어나지 않는다. 
> - 비동기방식 설계는 병렬적으로 작업을 진행하기 때문에 효율적이지만, 설계가 복잡한 단점이 있다.
- nginx는 주로 Node.js 서버 앞단의 프록시 서버로 활용
  - Node.js의 버퍼 오버플로우 취약점을 예방하기 위해서
- 익명 사용자의 직접적인 서버로의 접근 차단
- 간접적으로 한 단계를 더 거침으로써 보안성 강화
- 실제 포트를 숨길 수 있음
- 정적 자원 gzip 압축 가능
- 메인 서버 앞단에서 로깅 가능  
<img width="519" alt="image" src="https://user-images.githubusercontent.com/108309396/233788242-60499f08-f21d-4301-a82b-95c810fa92da.png">

> ### [참고] 버퍼 오버플로우
> - 버퍼: 데이터가 저장되는 메모리 공간
> - 즉 버퍼 오버플로우란 메모리 공간을 벗어나는 경우를 의미
> - 사용되지 않아야 할 영역에 데이터가 덮어씌워져 주소, 값을 바꾸는 공격이 발생하기도 함

> ### [참고] gzip 압축
> - DEFLATE 알고리즘 기반 압축 기술
> 데이터 전송량&darr;
> but 압축 해제 시 서버에서의 CPU overhead도 생각해서 사용 유무를 결정해야 함

## ✔️ 2. CloudFlare
- 전 세계적으로 분산된 서버가 있고 어떠한 시스템의 콘텐츠 전달을 빠르게 할 수 있는 CDN 서비스
  - CDN(Content Delivery Network): 각 사용자가 인터넷에 접속하는 곳과 가까운 곳에서 콘텐츠를 캐싱 또는 배포하는 서버 네트워크를 말함. 이를 통해 사용자가 웹 서버로부터 콘텐츠를 다운로드하는 시간을 줄일 수 있음
- CloudFlare를 웹 서버 앞단에서 프록시 서버로 활용 
- DDOS 공격 방어
  - DDOS란? 짧은 기간 동안 네트워크에 많은 요청을 보내 네트워크를 마비시켜 웹 사이트의 가용성을 방해하는 사이버 공격 유형
  - CloudFlare는 시스템을 통해 오는 트래픽을 자동으로 차단
- HTTPS 구축
  - CloudFlare를 사용하면 별도의 인증서 설치 없이 손쉽게 HTTPS 구축 가능

## ✔️ CORS와 프론트엔드의 프록시 서버
- CORS(Cross-Origin Resource Sharing): 서버가 웹 브라우저에서 리소스를 로드할 때 다른 오리진을 통해 로드하지 못하게 하는 HTTP 헤더 기반 알고리즘
  - 오리진이란? 프로토콜과 호스트 이름, 포트의 조합
  - `https://naver.com:12010/text/`라는 주소에서 오리진은 `https://naver.com:12010/`을 의미
- 프론트엔드 개발 시 프론트엔드 서버를 만들어서 백엔드 서버와 통신할 때 CORS 에러 발생 가능 &rarr; 프록시 서버로 해결 가능
  - 프록시 서버를 둬서 프론트엔드 서버에서 요청되는 오리진을 백엔드 오리진과 맞춤
1. 프록시 서버 이용 전   
<img width="407" alt="image" src="https://user-images.githubusercontent.com/108309396/233788759-b5edabd5-7b5d-444d-83fe-c92e67493da4.png">

2. 프록시 서버 이용 후  
<img width="412" alt="image" src="https://user-images.githubusercontent.com/108309396/233788773-11bb279b-30a7-4221-aa2b-8b15a4837780.png">


# 📌 1.1.6 이터레이터 패턴(Iterator Pattern)
- 이터레이터를 사용하여 컬렉션의 요소들에 접근하는 디자인 패턴
- 자료형과 관계없이 이터레이터라는 하나의 인터페이스로 순회 가능
- 사용 예시: 자바스크립트에서의 `for a of b` 이터레이터 프로토콜

# 📌 1.1.7 노출모듈 패턴(Revealing Module Pattern)
- 즉시 실행 함수를 통해 접근 제어자를 만드는 패턴
  - 즉시 실행 함수란? 함수를 정의하자마자 바로 호출하는 함수. 초기화 코드, 라이브러리 내 전역 변수의 충돌 방지 등에 사용

# 📌 1.1.8 MVC 패턴
- Model, View, Controller로 이루어진 디자인 패턴
- 애플리케이션의 구성 요소를 구분하여 개발 과정에서 각각의 요소에만 집중해서 개발 가능
- 재사용성과 확장성 용이
- but 애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해진다는 단점 존재
- 사용 예시: React.js(UI를 구축하기 위한 라이브러리)

## ✔️ Model
- 애플리케이션의 데이터인 데이터베이스, 상수, 변수
- 뷰에서 데이터를 생성하거나 수정하면 컨트롤러를 통해 모델을 생성하거나 갱신

## ✔️ View
- 사용자 인터페이스 요소
- 모델을 기반으로 사용자가 볼 수 있는 화면
- 화면에 표시하는 정보만 가지고 있음
- 변경이 일어나면 컨트롤러에 전달하는 역할

## ✔️ Controller
- 모델과 뷰를 잇는 다리 역할
- 메인 로직 담당
- 모델과 뷰의 생명 주기 관리
- 변경 통지를 받으면 이를 각각의 구성요소에 알려줌


                



# 📌 1.1.9 MVP 패턴
- MVC에서 Controller가 Presenter로 교체된 패턴
- 뷰와 프레젠터는 1:1 관계이기 때문에 MVC패턴보다 더 강한 결합을 지님  
<img width="522" alt="image" src="https://user-images.githubusercontent.com/108309396/233789886-ff942879-76b4-4108-a42a-57a027eefbbd.png">


# 📌 1.1.10 MVVM 패턴
- MVC에서 Controller가 View Model로 바뀐 패턴
- 뷰 모델은 뷰를 더 추상화한 계층
- 커맨드와 데이터 바인딩을 가지는 것이 특징
  - 커맨드란? 여러 가지 요소에 대한 처리를 하나의 액션으로 처리할 수 있는 기법
  - 데이터 바인딩이란? 화면에 보이는 데이터와 웹 브라우저의 메모리 데이터를 일치시키는 기법으로 뷰모델을 변경하면 뷰가 변경됨
- 뷰와 뷰모델 사이의 양방향 데이터 바인딩을 지원
- UI를 별도의 코드 수정 없이 재사용 가능
- 단위 테스팅 쉬움  
<img width="697" alt="image" src="https://user-images.githubusercontent.com/108309396/233789996-668a1335-3162-44e6-b429-715fa9090bd3.png">  

- 사용 예시: Vue.js(반응형이 특징인 프론트엔드 프레임워크)