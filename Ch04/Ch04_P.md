# 4. 데이터베이스

## 4.1. 데이터베이스의 기본

+ **데이터베이스** : 일정한 규칙, 규약을 통해 저장되는 데이터 모음
+ **DBMS** : 데이터베이스를 제어, 관리하는 통합 시스템
  + 데이터베이스 안에 있는 데이터들은 정의된 쿼리 언어를 통해 CRUD 가능.
  + 실시간접근 및 동시 공유가 가능

### 4.1.1 엔터티

여러 개의 속성을 지닌 명사.

+ 약한 엔터티 : 다른 엔터티의 존재 여부에 종속적
+ 강한 엔터티 : 다른 엔터티의 존재 여부와 독립적

### 4.1.2 릴레이션

데이터베이스에서 정보를 구분해 저장하는 기본 단위. 엔터티에 관한 데이터를 DB는 릴레이션 하나에 담아서 관리함

+ 릴레이션을 관계형 DB에서는 테이블, NoSQL DB에서는 컬렉션이라고 함.
+ 관계형 데이터베이스 : ex) MySql. 레코드-테이블-DB의 구조
+ NoSql : ex) MongoDB. 도큐먼트-컬렉션-DB의 구조

### 4.1.3 속성

릴레이션에서 관리하는, 구체적이며 고유한 이름을 갖는 정보

### 4.1.4 도메인

릴레이션에 포함된 각 속성들이 가질 수 있는 값의 집합

ex) 속성 '성별' -> 도메인 {남, 여}

### 4.1.5 필드와 레코드

+ 필드
+ 레코드 : 테이블에 쌓이는 행 단위의 데이터. 튜플이라고도 함

### 4.1.6 관계

데이터베이스 내 여러 테이블 사이에서도 관계를 정의할 수 있음

+ 1:1 관계
+ 1:N 관계
+ N:M 관계

### 4.1.7 키

테이블 간의 관계를 조금 더 명확하게 하고 테이블 자체의 인덱스를 위해 설정된 장치.

+ 기본키(Primary Key) : 유일성과 최소성을 만족하는 키
  + 자연키 : 테이블을 만들었을 때 자연스럽게 중복되지 않는 속성을 키로 만든 것. 언젠가는 변하는 속성
  + 인조키 : 인위적으로 생성해 부여한 고유 식별자. 변하지 않음.
+ 외래키(Foreign Key) : 다른 테이블의 기본키를 그대로 참조하는 값. 개체와의 관계를 식별하는 데 사용함
  + 중복되어도 괜찮음
+ 후보키(Candidate Key) : 기본키가 될 수 있는 후보. 유일성과 최소성을 동시에 만족
+ 대체키(Alternate Key) : 후보키가 둘 이상일 때 하나를 기본키로 지정하고 남은 후보키들
+ 슈퍼키(Super Key) : 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키입니다.

## 4.2 ERD와 정규화 과정

ERD(Entity Relationship Diagram) : 릴레이션 간의 관계를 정의한 것. DB 구축의 가장 기초적 뼈대 역할을 함

+ ERD는 관계형 구조로 표현할 수 있는 데이터를 구성하는 데에는 유용하지만,비정형 데이터는 충분히 표현할 수 없다는 단점을 가짐

### 4.2.3 정규화 과정

릴레이션 간의 잘못된 종속 관계로 인해 일어난 DB의 이상 현상(Anomaly)을 해결하거나, 저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러 개로 분리하는 과정. 정규형 원칙을 기반으로 정규형을 만들어가는 과정이며, 그 정도는 정규형(NF, Normal Form)으로 표현함.

+ 정규형 원칙
  + 같은 의미를 표현하는 릴레이션이라도 좀 더 좋은 구조로 만들어야 함.
  + 자료의 중복성은 감소.
  + 독립적인 관계는 별개의 릴레이션으로 표현
  + 각 릴레이션은 독립적인 표현이 가능해야 함
+ 정규화의 장점
  + DB 변경 시 이상 현상을 제거 가능
  + 정규화된 DB 구조에서는 새로운 데이터 형의 추가로 인한 확장 시, 그 구조를 변경하지 않아도 되거나 일부만 변경해도 됨
  + DB와 연동된 응용 프로그램에 최소한의 영향만을 미치게 됨
+ 정규화의 단점
  + 릴레이션의 분해로 인해 릴레이션 간의 JOIN 연산이 많아짐
  + 쿼리 응답 시간이 느려질 수도 있음
  + 데이터 처리 속도에 변화가 생길 수 있음
  + 많은 JOIN으로 성능 저하가 일어나면 반 정규화를 적용할 수도 있음

+ 기본 정규형
  + 제 1 정규형
    + 릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자값으로만 구성되어야 함
    + 한 기본키에 대해 둘 이상의 값을 가지는 반복 집합이 있어서는 안되며, 만약 반복 집합이 있다면 제거해야 함
      + 각 컬럼은 한 속성만을 가져야 한다.
      + 한 컬럼은 같은 종류나 타입의 값을 가져야 함
      + 각 컬럼이 유일한 이름을 가져야 함
      + 칼럼의 순서는 상관 없어야 함
  + 제 2 정규형
    + 릴레이션이 제 1 정규형이고 부분 함수의 종속성을 제거한 형태
    + 부분 함수의 종속성 제거
      + 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적
      + == 기본키의 부분집합이 결정자가 되어서는 안된다.
  + 제 3 정규형
    + 제 2 정규형이면서, 기본키가 아닌 모든 속성이 이행적 함수 종속(transitive FD)을 만족하지 않는 상태
  + 보이스/코드 정규형
    + 제 3 정규형이면서, 결정자가 후보키가 아닌 함수 종속 관계를 제거해 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 상태
    + 결정자 :함수 종속 관계에서 특정 종속자(dependent)를 결정짓는 요소.
+ 고급 정규형
  + 제 4 정규형
    + 보이스/코드 정규형이면서 다치 종속이 없는 상태
    + 다치 종속
      + A->B일 때 한 A 값에 여러 B값이 존재하는 경우
      + 최소 세 개의 칼럼이 존재해야 함
      + R(A, B, C)가 있을 때, A, B 사이에 다치 종속성이 있으면서 B, C는 독립적인 경우
  + 제 5 정규형
    + 중복을 제거하기 위해 분해할 수 있을 만큼 전부 분해하는 것
    + 제 4 정규형이면서 조인 종속이 없어야 함
      + 조인 종속 : 한 릴레이션을 여러 개의 릴레이션으로 무손실 분해 했다가 다시 결합할 수 있다면 조인 종속이라 함
    + 조인 연산을 했을 때 손실이 없어야 함
    + 현실의 DB는 제 5 정규형을 사용하지 않음

+ 

## 4.3 트랜잭션과 무결성

### 4,3,1 트랜잭션

DB에서 하나의 논리적 기능을 수행하기 위한 작업의 단위로서, 여러 쿼리를 하나로 묶는 단위. 

+ 트랜잭션의 특징(ACID)

  + 원자성(Atomicity)

    + 하나의 트랜잭션과 관련된 일은 모두 수행되거나 수행되지 않음.
    + All or Nothing
    + 트랜잭션 단위로 여러 로직을 묶을 때 외부 API를 호출해서는 안 됨.
      + 만약 있다면 롤백이 일어났을 때 어떻게 할지에 대한 해결 방법이 있어야 함
    + 커밋과 롤백
      + 커밋
        + 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어.
        + 트랜잭션 단위로 수행되며 변경된 내용이 모두 영구적으로 저장됨
      + 롤백
        + 에러나 여러 이슈로 트랜잭션 전으로 돌려야 하는 경우에 사용
        + 트랜잭션 과정이 일어나기 전으로 되돌리는 일
      + 커밋과 롤백 덕에 데이터의 무결성이 보장되며 데이터 변경 전에 변경 사항을 확인할 수 있고 해당 작업을 그룹화 할 수 있음
    + 트랜잭션 전파
      + 트랜잭션은 커넥션 단위로 수행되므로 커낵션 객체를 넘겨 수행해야 함.
      + 여러 트랜잭션 관련 메서드를 하나의 트랜잭션에 묶이도록 하는 것을 트랜잭션 전파라 함.
      + 스프링에서는 @Transactinal Annotation을 통해 여러 쿼리 코드를 하나의 트랜잭션으로 처리

  + 일관성(Consistency)

    + 허용된 방식으로만 데이터를 변경해야 하는 것을 의미.
    + DB의 모든 데이터는 여러 조건과 규칙에 따라서만 유혀함을 가져야 함.

  + 격리성(Isolation)

    + 복수의 병렬 트랜잭션은 서로 격리되어 순차적으로 실행되는 것처럼 작동해야 하고, DB는 여러 사용자가 같은 데이터에 접근할 수 있어야 함.

    + 여러 개의 격리 수준을 나누어 격리성을 보장함. [관련블로그](https://hudi.blog/transaction-isolation-level/)

      + SERIALIZABLE, REPEATABLE_READ, READ_COMMITTED, READ_UNCOMMITTED가 있고, 앞으로 갈수록 동시성이 강해지지만 격리성은 약해지고, 뒤로 갈수록 동시성은 약해지고 격리성은 강해짐.

      + SERIALIZABLE
        + 트랜잭션을 순차적으로 진행.
        + 여러 트랜잭션이 동시에 같은 행에 접근 불가.
        + 한 트랜잭션이 어떤 행에 접근하고 있다면, 그 행에 대해서 다른 트랜잭션은 대기.
        + 교착 상태가 일어날 확률도 많고 성능도 떨어짐 
      + REPEATABLE_READ
        + 한 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없게 막지만 새로운 행을 추가하는 것은 막지 않음
      + READ_COMMITTED
        + 가장 많이 사용됨.
        + 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없고, 커밋 완료된 데이터에 대해서만 조회를 허용함.
        + 어떤 트랜잭션이 접근한 행을 다른 트랜잭션이 수정할 수도 있음.
      + READ_UNCOMMITTED
        + 트랜잭션이 커밋되기 이전에 다른 트랜잭션에 노출되는 문제가 있으나 가장 빠름.
        + 데이터 무결성을 위해서는 사용하지 않는 것이 좋지만, 거대한 양의 데이터를 어림잡아 집계하는 데에는 사용할 만함.

      + 격리 수준에 따라 여러 현상이 발생할 수 있음
        + 팬텀리드 - REPEATABLE_READ, READ_COMMITTED, READ_UNCOMMITTED
          + 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우.
          + 다른 행이 선택되는 경우
        + 반복 가능하지 않은 조회(non-repeatable read) - READ_COMMITTED, READ_UNCOMMITTED
          + 한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했는데, 그 값이 다른 경우.
          + 같은 행의 값이 달라지는 경우
        + 더티 리드 - READ_UNCOMMITTED
          +  반복 가능하지 않은 조회와 유사.
          + 한 트랜잭션이 실행 중일 때, 다른 트랜잭션에 의해 수정됐지만 아직 커밋되즈 않은 행의 데이터를 읽을 수 있을 때 발생.

  + 지속성(Durability)

    + 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함. DB에 시스템 장애가 발생해도 원 상태로 복구하는 회복 기능이 있어야 함.
    + DB는 이를 위해 체크섬, 저널링, 롤백 등의 기능을 제공.
      + 체크섬 : 중복 검사의 한 형태. 오류 정정을 통해 송신된 자료의 무결성을 보호하는 단순한 방법
      + 저널링 : 파일 또는 DB 시스템에 변경 사항을 커밋하기 전에 로깅. 트랜잭션 등 변경 사항에 대한 로깅.

### 4.3.2 무결성

데이터의 정확성, 일관성, 유효성을 유지하는 것

+ 무결성의 종류
  + 개체 무결성
    + 기본키로 선택된 필드는 빈 값을 허용하지 않음
  + 참조 무결성
    + 서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지해야 함
  + 고유 무결성
    + unique하면 unique해야 함
  + NULL 무결성
    + non-null이면 non-null

## 4.4 데이터베이스의 종류

### 4.4.1 관계형 DB

행과 열을 가지는 표 형식으로 데이터를 저장하는 형태의 DB. SQL문으로 조작.

### 4.4.2 NoSQL DB

SQL을 사용하지 않는 DB. 대표적으로 MongoDB와 redis

+ MongoDB
  + JSON을 토애 데이터에 접근. Binary JSON형태로 데이터를 저장.

## 4.5. 인덱스

인덱스를 설정하면 테이블 내에서 내가 찾고자 하는 데이터를 빠르게 찾을 수 있음.

### 4.5.2 [B-tree](https://ko.wikipedia.org/wiki/B_%ED%8A%B8%EB%A6%AC)

인덱스는 보통 B-tree 자료 구조로 이루어져 있음. 이는 루트 노드, 리프 노드, 브랜치 노드로 나뉨.

특정 키를 찾기 위해 전체 테이블을 탐색하지 않고 해당 키가 있을 법한 리프노드로 들어가서 탐색.

맨 위 루트 노드부터, 브랜치 노드를 거쳐 리프노드로 내려감

+ 인덱스가 효율적인 이유와 대수확장성
  + 인덱스는 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조를 가짐
  + 트리 깊이의 대수확장성을 가짐
    + 대수확장성
      + 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장함.
      + 기본적으로 인덱스의 깊이가 하나 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가
      + 실제 인덱스는 훨씬 더 효율적

### 4.5.3 인덱스 만드는 방법

인덱스를 만드는 방법은 DB마다 다름.

+ MySQL

  + 클러스터형 인덱스와 세컨더리 인덱스가 있고, 클러스터형 인덱스는 테이블 당 하나를 설정할 수 있음.

  + `primary key` 옵션으로 기본키를 만들면 클러스터형 인덱스를 생성할 수 있고, PK를 만들지 않더라도 unique not null 옵션으로 클러스터형 인덱스를 만들 수 있음.

  + create index ... 명령어로 세컨더리 인덱스를 만들 수도 있음.

    + 한 인덱스만 생성할 때에는 클러스터형 인덱스를 만드는 것이 세컨더리 인덱스를 만드는 것보다 성능이 좋음.

    + 세컨더리 인덱스는 보조 인덱스로, 여러 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야 하는 인덱스.

+ MongoDB

  + 도큐먼트를 만들면 자동으로 ObjectID가 형성되고, 해당 키가 기본키로 설정됨. 세컨더리 키도 부가적으로 설정 가능.

### 4.5.4 인덱스 최적화 기법(MongoDB)

1. 인덱스는 비용

   인덱스는 인덱스 리스트 -> 컬렉션 순으로 두 번 탐색하므로 관련 비용이 듦.

   컬렉션이 수정되면 인덱스도 수정되어야 함.

   쿼리에 있는 필드에 인덱스를 다 설정하는 것은 비효율적이며 컬렉션에서 가져와야 하는 양이 많을 수록 인덱스를 사용하는 것은 비효율적

2. 항상 테스팅 

   항상 테스팅하는 게 중요함

3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순

   여러 필드를 기반으로 조회할 때 복합 인덱스를 생성하는데, 이 인덱스를 생성할 때에는 순서가 있고, 생성 순서에 따라 인덱스 성능도 달라짐.

   

## 4.6 조인의 종류

join : 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것. MySQL에서는 JOIN, MongoDB에서는 lookup

+ 조인의 종류
  + inner join
    + 왼쪽 오른쪽 테이블의 두 행이 모두 일치하는 행이 있는 부분만 표기
    + 교집합
  + left outer join
    + 왼쪽 테이블의 모든 행이 결과 테이블에 표기
    + 오른쪽 테이블과 일치하는 부분의 레코드와 함께 왼쪽 테이블을 기준으로 완전한 레코드 집합을 생성.
    + 만약 오른쪽에 일치하는 게 없으면 해당 값은 null 처리
  + right outer join : 오른쪽 테이블의 모든 행이 결과 테이블에 표기
  + full outer join
    + 두 테이블을 기반으로 조인 조건을 만족하지 않는 행까지 모두 표기
    + 합집합
    + 양쪽 테이블에서 일치하는 레코드와 함께 두 테이블의 모든 레코드 집합을 생성.
    + 일치하는 항목이 없으면 누락된 쪽에 null 값이 포함되어 출력됨.

## 4.7 조인의 원리

### 4.7.1 중첩 루프 조인 (NLJ, Nested Loop Join)

nested for 문과 같은 원리로 조건에 맞는 조인을 하는 방법. 랜덤 접근에 대한 비용이 많이 증가해서 대용량 테이블에서는 사용하지 않음

### 4.7.2 정렬 병합 조인

각 테이블을 조인할 필드 기준으로 정렬하고, 정렬이 끝난 후에 조인 작업을 수행.

조인 시 적절한 인덱스가 없고 대용량 테이블들을 조인하고, 조인 조건에 범위 비교 연산자가 있을 때 사용

### 4.7.3 해시 조인

해시 테이블을 기반으로 조인하는 방법. 두 테이블으 조인했을 때 한 테이블이 메모리에 온전히 들어가는 경우 보통 중첩 루프 조인보다 더 효율적임.

동등 조인에서만 사용할 수 있음.

+ MySQL의 해시 조인 단계

  + 빌드 단계

    입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드하는 단계

    두 테이블을 조인 할 때 더 작은 바이트를 가지는 테이블을 기반으로 테이블을 빌드

    조인에 사용되는 필드가 해시 테이블의 키로 사용됨

  + 프로브 단계

    레코드 읽기를 시작. 빌드 테이블이 아닌 나머지 테이블의 레코드를 읽어 해시 테이블과 일치하는 레코드를 찾는 과정.

